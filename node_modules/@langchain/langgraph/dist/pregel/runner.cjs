"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PregelRunner = void 0;
const types_js_1 = require("./types.cjs");
const constants_js_1 = require("../constants.cjs");
const errors_js_1 = require("../errors.cjs");
const retry_js_1 = require("./retry.cjs");
/**
 * Responsible for handling task execution on each tick of the {@link PregelLoop}.
 */
class PregelRunner {
    /**
     * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.
     * @param loop - The PregelLoop that produces tasks for this runner to execute.
     */
    constructor({ loop, nodeFinished, }) {
        Object.defineProperty(this, "nodeFinished", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "loop", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.loop = loop;
        this.nodeFinished = nodeFinished;
    }
    /**
     * Execute tasks from the current step of the PregelLoop.
     *
     * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.
     * @param options - Options for the execution.
     */
    async tick(options = {}) {
        const { timeout, signal, retryPolicy, onStepWrite } = options;
        let graphBubbleUp;
        // Start task execution
        const pendingTasks = Object.values(this.loop.tasks).filter((t) => t.writes.length === 0);
        const taskStream = this._executeTasksWithRetry(pendingTasks, {
            stepTimeout: timeout,
            signal,
            retryPolicy,
        });
        for await (const { task, error } of taskStream) {
            this._commit(task, error);
            if ((0, errors_js_1.isGraphInterrupt)(error)) {
                graphBubbleUp = error;
            }
            else if ((0, errors_js_1.isGraphBubbleUp)(error) && !(0, errors_js_1.isGraphInterrupt)(graphBubbleUp)) {
                graphBubbleUp = error;
            }
        }
        onStepWrite?.(this.loop.step, Object.values(this.loop.tasks)
            .map((task) => task.writes)
            .flat());
        if ((0, errors_js_1.isGraphInterrupt)(graphBubbleUp)) {
            throw graphBubbleUp;
        }
        if ((0, errors_js_1.isGraphBubbleUp)(graphBubbleUp) && this.loop.isNested) {
            throw graphBubbleUp;
        }
    }
    /**
     * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.
     * @param tasks - The tasks to execute.
     * @param options - Options for the execution.
     */
    async *_executeTasksWithRetry(tasks, options) {
        const { stepTimeout, retryPolicy } = options ?? {};
        let signal = options?.signal;
        const promiseAddedSymbol = Symbol.for("promiseAdded");
        let addedPromiseSignal;
        let addedPromiseWait;
        function waitHandler(resolve) {
            addedPromiseSignal = () => {
                addedPromiseWait = new Promise(waitHandler);
                resolve(promiseAddedSymbol);
            };
        }
        addedPromiseWait = new Promise(waitHandler);
        const executingTasksMap = {};
        const writer = (task, writes, { calls } = {}) => {
            if (writes.every(([channel]) => channel !== constants_js_1.PUSH)) {
                return task.config?.configurable?.[constants_js_1.CONFIG_KEY_SEND]?.(writes) ?? [];
            }
            // Schedule PUSH tasks, collect promises
            const scratchpad = task.config?.configurable?.[constants_js_1.CONFIG_KEY_SCRATCHPAD];
            const rtn = {};
            for (const [idx, write] of writes.entries()) {
                const [channel] = write;
                if (channel !== constants_js_1.PUSH) {
                    continue;
                }
                const wcall = calls?.[idx];
                const cnt = scratchpad.callCounter;
                scratchpad.callCounter += 1;
                if (wcall == null) {
                    throw new Error("BUG: No call found");
                }
                const nextTask = this.loop.acceptPush(task, cnt, wcall);
                if (!nextTask) {
                    continue;
                }
                // Check if this task is already running
                const existingPromise = executingTasksMap[nextTask.id];
                if (existingPromise !== undefined) {
                    // If the parent task was retried, the next task might already be running
                    rtn[idx] = existingPromise;
                }
                else if (nextTask.writes.length > 0) {
                    // If it already ran, return the result
                    const returns = nextTask.writes.filter(([c]) => c === constants_js_1.RETURN);
                    const errors = nextTask.writes.filter(([c]) => c === constants_js_1.ERROR);
                    if (returns.length > 0) {
                        // Task completed successfully
                        if (returns.length === 1) {
                            rtn[idx] = Promise.resolve(returns[0][1]);
                        }
                        else {
                            // should be unreachable
                            throw new Error(`BUG: multiple returns found for task ${nextTask.name}__${nextTask.id}`);
                        }
                    }
                    else if (errors.length > 0) {
                        if (errors.length === 1) {
                            const errorValue = errors[0][1];
                            // Task failed
                            const error = 
                            // eslint-disable-next-line no-instanceof/no-instanceof
                            errorValue instanceof Error
                                ? errorValue
                                : new Error(String(errorValue));
                            rtn[idx] = Promise.reject(error);
                        }
                        else {
                            // the only way this should happen is if the task executes multiple times and writes aren't cleared
                            throw new Error(`BUG: multiple errors found for task ${nextTask.name}__${nextTask.id}`);
                        }
                    }
                }
                else {
                    // Schedule the next task with retry
                    const prom = (0, retry_js_1._runWithRetry)(nextTask, retryPolicy, {
                        [constants_js_1.CONFIG_KEY_SEND]: writer.bind(this, nextTask),
                        // eslint-disable-next-line @typescript-eslint/no-use-before-define
                        [constants_js_1.CONFIG_KEY_CALL]: call.bind(this, nextTask),
                    });
                    executingTasksMap[nextTask.id] = prom;
                    addedPromiseSignal();
                    rtn[idx] = prom.then(({ result, error }) => {
                        if (error) {
                            return Promise.reject(error);
                        }
                        return result;
                    });
                }
            }
            return Object.values(rtn);
        };
        const call = (task, func, name, input, options = {}) => {
            const result = writer(task, [[constants_js_1.PUSH, null]], {
                calls: [
                    new types_js_1.Call({
                        func,
                        name,
                        input,
                        retry: options.retry,
                        callbacks: options.callbacks,
                    }),
                ],
            });
            // eslint-disable-next-line no-instanceof/no-instanceof
            if (result !== undefined) {
                if (result.length === 1) {
                    return result[0];
                }
                return Promise.all(result);
            }
            return Promise.resolve();
        };
        if (stepTimeout && signal) {
            if ("any" in AbortSignal) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                signal = AbortSignal.any([
                    signal,
                    AbortSignal.timeout(stepTimeout),
                ]);
            }
        }
        else if (stepTimeout) {
            signal = AbortSignal.timeout(stepTimeout);
        }
        if (signal?.aborted) {
            // note: don't use throwIfAborted here because it throws a DOMException,
            // which isn't consistent with how we throw on abort below.
            throw new Error("Abort");
        }
        // Start tasks
        Object.assign(executingTasksMap, Object.fromEntries(tasks.map((pregelTask) => {
            return [
                pregelTask.id,
                (0, retry_js_1._runWithRetry)(pregelTask, retryPolicy, {
                    [constants_js_1.CONFIG_KEY_SEND]: writer?.bind(this, pregelTask),
                    [constants_js_1.CONFIG_KEY_CALL]: call?.bind(this, pregelTask),
                }).catch((error) => {
                    return { task: pregelTask, error };
                }),
            ];
        })));
        let listener;
        const signalPromise = new Promise((_resolve, reject) => {
            listener = () => reject(new Error("Abort"));
            signal?.addEventListener("abort", listener);
        }).finally(() => signal?.removeEventListener("abort", listener));
        while (Object.keys(executingTasksMap).length > 0) {
            const settledTask = await Promise.race([
                ...Object.values(executingTasksMap),
                signalPromise,
                addedPromiseWait,
            ]);
            if (settledTask === promiseAddedSymbol) {
                continue;
            }
            yield settledTask;
            delete executingTasksMap[settledTask.task.id];
        }
    }
    /**
     * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.
     *
     * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.
     *
     * @param task - The task to commit.
     * @param error - The error that occurred, if any.
     */
    _commit(task, error) {
        if (error !== undefined) {
            if ((0, errors_js_1.isGraphInterrupt)(error)) {
                if (error.interrupts.length) {
                    const interrupts = error.interrupts.map((interrupt) => [constants_js_1.INTERRUPT, interrupt]);
                    const resumes = task.writes.filter((w) => w[0] === constants_js_1.RESUME);
                    if (resumes.length) {
                        interrupts.push(...resumes);
                    }
                    this.loop.putWrites(task.id, interrupts);
                }
            }
            else if ((0, errors_js_1.isGraphBubbleUp)(error) && task.writes.length) {
                this.loop.putWrites(task.id, task.writes);
            }
            else {
                this.loop.putWrites(task.id, [
                    [constants_js_1.ERROR, { message: error.message, name: error.name }],
                ]);
                // TODO: is throwing here safe? what about commits from other concurrent tasks?
                throw error;
            }
        }
        else {
            if (this.nodeFinished &&
                (task.config?.tags == null || !task.config.tags.includes(constants_js_1.TAG_HIDDEN))) {
                this.nodeFinished(String(task.name));
            }
            if (task.writes.length === 0) {
                // Add no writes marker
                task.writes.push([constants_js_1.NO_WRITES, null]);
            }
            // Save task writes to checkpointer
            this.loop.putWrites(task.id, task.writes);
        }
    }
}
exports.PregelRunner = PregelRunner;
//# sourceMappingURL=runner.js.map