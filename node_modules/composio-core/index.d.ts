import { AiTextGenerationToolInput, AiTextGenerationOutput } from '@cloudflare/workers-types';
import { z, ZodObject, ZodString, ZodOptional } from 'zod';
import * as axios from 'axios';
import { AxiosInstance } from 'axios';
import { DynamicStructuredTool } from '@langchain/core/tools';
import { OpenAI } from 'openai';
import { Stream } from 'openai/streaming';
import { CoreTool } from 'ai';

export type TriggerData = {
    appName: string;
    clientId: number;
    payload: Record<string, unknown>;
    originalPayload: Record<string, unknown>;
    metadata: {
        id: string;
        connectionId: string;
        triggerName: string;
        triggerData: string;
        triggerConfig: Record<string, unknown>;
        connection: {
            id: string;
            integrationId: string;
            clientUniqueUserId: string;
            status: string;
        };
    };
};

/**
 * Class representing the details required to initialize and configure the API client.
 */
export declare class AxiosBackendClient {
    /**
     * The API key used for authenticating requests.
     */
    apiKey: string;
    /**
     * The base URL of the API against which requests will be made.
     */
    baseUrl: string;
    /**
     * The runtime environment where the client is being used.
     */
    runtime: string;
    instance: AxiosInstance;
    /**
     * Creates an instance of apiClientDetails.
     * @param {string} apiKey - The API key for client initialization.
     * @param {string} baseUrl - The base URL for the API client.
     * @param {string} runtime - The runtime environment identifier.
     * @throws Will throw an error if the API key is not provided.
     */
    constructor(apiKey: string, baseUrl: string, runtime?: string);
    /**
     * Retrieves the client ID from the user's information.
     * @returns {Promise<string>} A promise that resolves to the client ID.
     * @throws Will throw an error if the HTTP request fails.
     */
    getClientId(): Promise<string>;
    /**
     * Initializes the API client with the provided configuration.
     * @private
     */
    private initializeApiClient;
    getAxiosInstance(): AxiosInstance;
}

/**
 * Team Member information
 */
export type MemberInfoResDTO = {
    /**
     * The ID/UUID of the member.
     */
    id: string;
    /**
     * The ID/UUID of the organization to which the member belongs.
     */
    orgId: string;
    /**
     * The email address of the member.
     */
    email: string;
    /**
     * The name of the member.
     */
    name: string;
    /**
     * The role of the member.
     */
    role: "admin" | "developer";
    /**
     * The metadata of the member. This store some additional information about the member.
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * The date and time when the member was created.
     */
    createdAt: string;
    /**
     * The date and time when the member was last updated.
     */
    updatedAt: string;
    /**
     * The date and time when the member was deleted.
     */
    deletedAt?: string;
};
export type BadRequestError = {
    /**
     * Additional arguments that caused the error
     */
    details: {
        [key: string]: unknown;
    };
    /**
     * The type of error
     */
    type: "BadRequestError";
    /**
     * HTTP status code
     */
    status: number;
    /**
     * Error message
     */
    message: string;
    /**
     * Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.
     */
    requestId: string;
};
export type NotFoundError = {
    /**
     * The name of the operation that caused the error
     */
    type: "NotFoundError";
    /**
     * HTTP status code
     */
    status: number;
    /**
     * Error message
     */
    message: string;
    /**
     * Request ID, used for tracing the request. This is very helpful for internal teams to debug issues.
     */
    requestId: string;
};
export type DeleteRowAPIDTO = {
    /**
     * Status of the delete operation
     */
    status: "success" | "failed";
    /**
     * Number of records deleted
     */
    count: number;
};
export type SingleAppInfoResDTO = {
    /**
     * Unique identifier (UUID) for the app
     */
    appId: string;
    /**
     * Unique key/slug used to identify the app in URLs and API calls.
     */
    key: string;
    /**
     * Human-readable display name of the app
     */
    name: string;
    /**
     * Short description about the app
     */
    description: string;
    /**
     * URL to the app's logo image, used for UI display
     */
    logo?: string;
    /**
     * The categories of the app
     */
    categories?: Array<string>;
    /**
     * The documentation URL of the app, if available. Usually it's a link to the doc to setup and configure the app.
     */
    docs?: string;
    /**
     * The configuration documentation text of the app. This is deprecated and not used anywhere.
     * @deprecated
     */
    configuration_docs_text?: string;
    /**
     * The status of the app. This is deprecated and not used anymore.
     * @deprecated
     */
    status?: string;
    /**
     * The documentation text of the app. This is deprecated and not used anywhere.
     * @deprecated
     */
    documentation_doc_text?: string;
    /**
     * The test connectors available for the app. If this is not empty, it means composio allows you to setup this app without configuring and setting up your own auth app.
     */
    testConnectors?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Indicates if the app is of `no_auth` type. If this is true, you can directly use the app without creating any integration.
     */
    no_auth?: boolean;
    /**
     * The authentication schemes supported by the app. This contains all the fields and details needed to setup and configure auth for this app.
     */
    auth_schemes?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * The metadata of the app
     */
    meta?: unknown;
};
export type TestConnector = {
    /**
     * The id of the test connector
     */
    id: string;
    /**
     * The name of the test connector
     */
    name: string;
    /**
     * The auth scheme of the test connector
     */
    authScheme: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | "CALCOM_AUTH";
};
export type AppInfoResponseDto = {
    /**
     * Unique identifier (UUID) for the app
     */
    appId: string;
    /**
     * Unique key/slug for the app, used in URLs and API references
     */
    key: string;
    /**
     * The name of the app
     */
    name: string;
    /**
     * The description of the app
     */
    description: string;
    /**
     * The logo of the app
     */
    logo: string;
    /**
     * The categories of the app
     */
    categories: string;
    /**
     * The tags of the app
     */
    tags?: string;
    /**
     * The authentication schemes of the app
     */
    auth_schemes?: unknown;
    /**
     * The authentication schemes of the app
     */
    testConnectors?: TestConnector;
    /**
     * Indicates if the app is enabled
     */
    enabled: boolean;
    /**
     * Indicates if the app has no authentication
     */
    no_auth?: boolean;
    /**
     * The creation date of the app
     */
    createdAt: string;
    /**
     * The last update date of the app
     */
    updatedAt: string;
};
export type ExpectedInputFieldsDTO = {
    /**
     * The unique identifier/key for this input field that will be used when submitting values. Must be URL-safe.
     */
    name: string;
    /**
     * The data type of this field. Common types include 'string', 'number', 'boolean', etc.
     */
    type: string;
    /**
     * Detailed explanation of what this field is used for and any special requirements or formatting needed.
     */
    description: string;
    /**
     * Human-readable label that will be shown to users when they need to input this field.
     */
    display_name: string;
    /**
     * Default value for this field if none is provided. Set to null if no default exists.
     */
    default: {
        [key: string]: unknown;
    };
    /**
     * Indicates if this field must be provided for the connector to function properly.
     */
    required: boolean;
    /**
     * Indicates if this field needs to be provided by the end user rather than being automatically populated.
     */
    expected_from_customer: boolean;
    /**
     * If true, this field contains sensitive information and should be handled securely (e.g. passwords, API keys).
     */
    is_secret: boolean;
};
export type GetConnectorInfoResDTO = {
    /**
     * Unique identifier for the connector. You can use this ID when calling endpoints like `POST /api/v1/connectedAccounts` to create connections.
     */
    id?: string;
    /**
     * The authentication method used by this connector. Refer to the API documentation for supported authentication schemes.
     */
    authScheme?: string;
    /**
     * The display name of this specific connector configuration.
     */
    name?: string;
    /**
     * ISO 8601 timestamp of when this connector was created.
     */
    createdAt?: string;
    /**
     * ISO 8601 timestamp of when this connector was last modified.
     */
    updatedAt?: string;
    /**
     * Whether this connector is currently active and can be used to create new connections. Can be toggled using the connector management endpoints.
     */
    enabled: boolean;
    /**
     * Soft deletion status of the connector. If true, the connector has been marked for deletion but may still exist in the system.
     */
    deleted?: boolean;
    /**
     * The ID of the application this connector belongs to. You can find available apps using the `GET /api/v1/apps` endpoint.
     */
    appId: string;
    /**
     * If this is a custom connector, this field may reference the original template connector it was based on.
     */
    defaultConnectorId?: string;
    /**
     * Configuration object containing authentication settings. Sensitive values will be redacted. The structure varies based on the authScheme.
     */
    authConfig: {
        [key: string]: unknown;
    };
    /**
     * List of fields that need to be collected from users to set up a connection using this connector. These fields should be included when calling `POST /api/v1/connectedAccounts`.
     */
    expectedInputFields: Array<ExpectedInputFieldsDTO>;
    /**
     * URL to the application's logo image that can be displayed in the UI.
     */
    logo: string;
    /**
     * The name of the application this connector integrates with.
     */
    appName: string;
    /**
     * When true, indicates that this connector uses Composio's built-in authentication handling rather than custom authentication logic.
     */
    useComposioAuth: boolean;
    /**
     * Array of action strings that this connector is limited to.
     */
    limitedActions: Array<string>;
};
/**
 * List of connectors with their details and associated connections
 */
export type ConnectorListItemDTO = {
    /**
     * Name of the application associated with this connector. You can find this in the response of the `GET /api/v1/apps` endpoint.
     */
    appName: string;
    /**
     * Aggregate count of connections associated with this connector. This helps track how many connected accounts are using this connector configuration.
     */
    _count: {
        [key: string]: unknown;
    };
    /**
     * List of connections associated with this connector, including their IDs and request log counts. Each connection represents a unique connected account using this connector configuration.
     */
    connections: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Unique identifier (UUID) of the connector. You can use this ID when calling endpoints like `GET /api/v1/connectors/{id}` or `PUT /api/v1/connectors/{id}`.
     */
    id: string;
    member: MemberInfoResDTO;
    /**
     * Display name of the connector. This name is used to identify the connector in the UI and API responses.
     */
    name: string;
    /**
     * Authentication scheme used by this connector. Determines how authentication is handled for connected accounts. See the Authentication Schemes section in the API documentation for more details.
     */
    authScheme: string;
    /**
     * Timestamp when this connector was created. Returned in ISO 8601 format.
     */
    createdAt: string;
    /**
     * Timestamp when this connector was last updated. Returned in ISO 8601 format.
     */
    updatedAt: string;
    /**
     * Indicates whether the connector is currently enabled. Disabled connectors cannot be used to create new connections.
     */
    enabled: boolean;
    /**
     * Soft deletion flag for the connector. When true, the connector is marked as deleted but remains in the database. You can filter deleted connectors using the `includeDeleted` query parameter in list endpoints.
     */
    deleted?: boolean;
    /**
     * Unique identifier (UUID) of the app this connector belongs to. You can use this ID to fetch app details via the `GET /api/v1/apps/{id}` endpoint.
     */
    appId: string;
    /**
     * ID of the default connector configuration. When present, this indicates that this connector inherits settings from the specified default connector. You can manage default connectors via the `/api/v1/defaultConnectors` endpoints.
     */
    defaultConnectorId?: string;
};
export type GetConnectorListResDTO = {
    /**
     * Array of connector items matching the query parameters. Each item contains detailed information about a connector and its associated connections.
     */
    items: Array<ConnectorListItemDTO>;
    /**
     * Total number of pages available based on the current page size. Use this for implementing pagination controls.
     */
    totalPages: number;
    /**
     * Current page number (1-based). You can request different pages using the `page` query parameter in the `GET /api/v1/connectors` endpoint.
     */
    page: number;
};
type ConnectionParams$1 = {
    /**
     * The ID of the integration this connection belongs to. You can get this from the [/api/v1/integrations](/api-reference/integrations/list-integrations) endpoint.
     */
    integrationId: string;
    /**
     * Additional parameters specific to this connection. Structure varies by integration type.
     */
    connectionParams?: {
        [key: string]: unknown;
    };
    /**
     * Flag indicating if this connection is currently disabled.
     */
    isDisabled: boolean;
    /**
     * Number of times this connection has been invoked/used.
     */
    invocationCount: number;
    id: string;
    clientUniqueUserId?: string;
    status: string;
    data?: {
        [key: string]: unknown;
    };
    deleted?: boolean;
    enabled?: boolean;
    createdAt: string;
    updatedAt: string;
    appUniqueId: string;
    appName: string;
    logo?: string;
    authConfig?: {
        [key: string]: unknown;
    };
    member: {
        [key: string]: unknown;
    };
    labels?: Array<string>;
};
/**
 * Additional information related to the connected account.
 */
export type Meta = {
    /**
     * App-specific metadata.
     */
    app: {
        [key: string]: unknown;
    };
};
export type ConnectedAccountResponseDTO = {
    /**
     * The ID of the integration to which the connected account belongs. You can get this from the [/api/v1/integrations](/api-reference/integrations/list-integrations) endpoint.
     */
    integrationId: string;
    /**
     * The unique ID of the app to which the connected account belongs. To get the full app info, you can use the [/api/v1/apps](/api-reference/apps/get-single-app) endpoint.
     */
    appUniqueId: string;
    memberInfo?: MemberInfoResDTO;
    meta?: Meta;
    /**
     * Flag to indicate if the connected account is disabled. If this is true, the connected account will not be able to be used for any actions.
     */
    isDisabled?: boolean;
    /**
     * The unique identifier for this connected account.
     */
    id: string;
    /**
     * The entityId to which the connected account belongs. **Deprecated: ** Please use the `entityId` field instead.
     * @deprecated
     */
    clientUniqueUserId: string;
    /**
     * The name of the app this account is connected to. You can get the list of available apps from the [/api/v1/apps](/api-reference/apps/list-apps) endpoint.
     */
    appName: string;
    /**
     * The entity ID associated with the connection. Learn more about entities [here](https://docs.composio.dev/patterns/Auth/connected_account#entities).
     */
    entityId: string;
    /**
     * The current status of the connection (e.g. 'active', 'inactive', 'pending').
     */
    status: "INITIATED" | "ACTIVE" | "FAILED" | "EXPIRED";
    /**
     * Flag to indicate if the connected account is enabled. This will be true if the connected account is active and can be used to perform actions.
     */
    enabled?: boolean;
    /**
     * The date and time when the connected account was created.
     */
    createdAt: string;
    /**
     * The date and time when the connected account was last updated.
     */
    updatedAt: string;
};
export type GetConnectionsResponseDto = {
    /**
     * Array of connection objects matching the query parameters.
     */
    items: Array<ConnectionParams$1>;
    /**
     * Total number of pages available based on the pageSize.
     */
    totalPages: number;
    /**
     * Current page number in the pagination.
     */
    page: number;
};
/**
 * The parameters to send with the request. This contains all the headers, query params, etc. that are required to make requests to the third-party service directly.
 */
export type Parameter = {
    /**
     * The name of the parameter. For example, 'x-api-key', 'Content-Type', etc.
     */
    name: string;
    /**
     * The location of the parameter. Can be 'query' or 'header'.
     */
    in: "query" | "header";
    /**
     * The value of the parameter. For example, '1234567890', 'application/json', etc.
     */
    value: string;
};
export type InitiateConnectionResponse = {
    /**
     * The current status of the initiated connection.
     */
    connectionStatus: string;
    /**
     * The ID of the newly created connected account.
     */
    connectedAccountId: string;
    /**
     * URL to redirect to for completing the connection process, if required.
     */
    redirectUrl?: string;
};
export type TriggerResDTO = {
    /**
     * Unique identifier of the trigger. This is used to reference the trigger in other API calls.
     */
    name: string;
    /**
     * Human-readable name of the trigger shown in the UI.
     */
    display_name: string;
    /**
     * Detailed description of what the trigger does.
     */
    description?: string;
    /**
     * Indicates whether the trigger is currently enabled.
     */
    enabled?: boolean;
    /**
     * Configuration parameters required for the trigger. Structure varies based on trigger type.
     */
    config?: {
        [key: string]: unknown;
    };
    /**
     * Sample payload that will be sent when the trigger fires.
     */
    payload?: {
        [key: string]: unknown;
    };
    /**
     * URL of the trigger's icon or logo.
     */
    logo?: string;
    /**
     * Number of times this trigger has been activated.
     */
    count?: number;
    /**
     * Unique key identifying the app this trigger belongs to.
     */
    appKey: string;
    /**
     * Unique identifier of the app this trigger belongs to. You can get this from the `id` field in the response of the `GET /api/v1/apps` endpoint.
     */
    appId: string;
    /**
     * Name of the app this trigger belongs to.
     */
    appName: string;
    /**
     * Step-by-step instructions on how to set up and use this trigger.
     */
    instructions?: string;
    /**
     * Classification or category of the trigger.
     */
    type?: string;
};
export type ActionExecutionResDto = {
    /**
     * The response data returned by the action execution.
     */
    data: {
        [key: string]: unknown;
    };
    /**
     * The error message, if the action failed to execute. If the action is successful, this will be null.
     */
    error?: string;
    /**
     * Whether the action execution was successfully executed or not. If this is false, error field will be populated with the error message.
     * @deprecated
     */
    successfull?: boolean;
    /**
     * Whether the action execution was successfully executed or not. If this is false, error field will be populated with the error message.
     */
    successful: boolean;
};
export type ActionDetails = {
    /**
     * Required parameters for the action to execute. For example, if the action is GMAIL_SEND_EMAIL, the required parameters for actions execution would be the email address, subject, and body.
     */
    parameters: {
        [key: string]: unknown;
    };
    /**
     * Expected response structure after action execution. You can use this to quickly check what happened with the action execution.
     */
    response: {
        [key: string]: unknown;
    };
    /**
     * The name of the app that the action belongs to. This is same as appId.
     */
    appKey: string;
    /**
     * The name of the app that the action belongs to,
     */
    appName: string;
    /**
     * The id of the app that the action belongs to. This is same as the appKey. Please use appKey instead.
     * @deprecated
     */
    appId: string;
    /**
     * Version of the action schema.
     */
    version: string;
    /**
     * List of availavle versions of the action.
     */
    available_versions: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Whether or not the action requires auth or not
     */
    no_auth: boolean;
    /**
     * The description of the action, tailored to improve the LLM accuracy and reasoning. Use this a tool/function description.
     */
    description: string;
    /**
     * The display name of the action, used to identify the action in the UI.
     */
    displayName: string;
    /**
     * The logo of the app that the action belongs to.
     */
    logo: string;
    /**
     * The name of the action, used to identify the action in the UI.
     */
    name: string;
    /**
     * The tags of the action, used to categorize the action in the UI.
     */
    tags: Array<string>;
    /**
     * Whether the action is deprecated, if true, avoid using this action.
     */
    deprecated?: boolean;
};
export type ActionsListResponseDTO = {
    items: Array<ActionDetails>;
    /**
     * Current page number in the paginated response
     */
    page: number;
    /**
     * Total number of pages available
     */
    totalPages: number;
};
export type InitiateConnectionError = BadRequestError | NotFoundError;
export type ListTriggersResponse = Array<TriggerResDTO>;

export declare const ZTriggerQuery: z.ZodObject<{
    triggerIds: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    triggerInstanceIds: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    appNames: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    appUniqueKeys: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    connectedAccountIds: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    integrationIds: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    showEnabledOnly: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    showEnabledOnly?: boolean | undefined;
    triggerIds?: string[] | undefined;
    connectedAccountIds?: string[] | undefined;
    integrationIds?: string[] | undefined;
    appNames?: string[] | undefined;
    appUniqueKeys?: string[] | undefined;
    triggerInstanceIds?: string[] | undefined;
}, {
    showEnabledOnly?: boolean | undefined;
    triggerIds?: string[] | undefined;
    connectedAccountIds?: string[] | undefined;
    integrationIds?: string[] | undefined;
    appNames?: string[] | undefined;
    appUniqueKeys?: string[] | undefined;
    triggerInstanceIds?: string[] | undefined;
}>;
export declare const ZTriggerInstanceItems: z.ZodObject<{
    triggerInstanceId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    triggerInstanceId: string;
}, {
    triggerInstanceId: string;
}>;
export declare const ZTriggerSetupParam: z.ZodObject<{
    connectedAccountId: z.ZodString;
    triggerName: z.ZodString;
    config: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}, "strip", z.ZodTypeAny, {
    connectedAccountId: string;
    triggerName: string;
    config?: Record<string, unknown> | undefined;
}, {
    connectedAccountId: string;
    triggerName: string;
    config?: Record<string, unknown> | undefined;
}>;
export declare const ZTriggerSubscribeParam$1: z.ZodObject<{
    appName: z.ZodOptional<z.ZodString>;
    triggerId: z.ZodOptional<z.ZodString>;
    connectionId: z.ZodOptional<z.ZodString>;
    integrationId: z.ZodOptional<z.ZodString>;
    triggerName: z.ZodOptional<z.ZodString>;
    triggerData: z.ZodOptional<z.ZodString>;
    entityId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    integrationId?: string | undefined;
    appName?: string | undefined;
    entityId?: string | undefined;
    connectionId?: string | undefined;
    triggerName?: string | undefined;
    triggerId?: string | undefined;
    triggerData?: string | undefined;
}, {
    integrationId?: string | undefined;
    appName?: string | undefined;
    entityId?: string | undefined;
    connectionId?: string | undefined;
    triggerName?: string | undefined;
    triggerId?: string | undefined;
    triggerData?: string | undefined;
}>;
export declare const ZSingleTriggerParam: z.ZodObject<{
    triggerId: z.ZodOptional<z.ZodString>;
    triggerName: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    triggerName?: string | undefined;
    triggerId?: string | undefined;
}, {
    triggerName?: string | undefined;
    triggerId?: string | undefined;
}>;
export declare const ZTriggerInstanceParam: z.ZodObject<{
    triggerInstanceId: z.ZodOptional<z.ZodString>;
    triggerId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    triggerId?: string | undefined;
    triggerInstanceId?: string | undefined;
}, {
    triggerId?: string | undefined;
    triggerInstanceId?: string | undefined;
}>;
export type TriggerSingleParam = z.infer<typeof ZSingleTriggerParam> & {
    triggerName?: string;
    /** @deprecated use triggerName field instead */
    triggerId?: string;
};
export declare const ZSingleTriggerRes: z.ZodObject<{
    name: z.ZodString;
    displayName: z.ZodString;
    description: z.ZodString;
    type: z.ZodString;
    appId: z.ZodString;
    appName: z.ZodString;
    instructions: z.ZodOptional<z.ZodString>;
    payload: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    config: z.ZodRecord<z.ZodString, z.ZodUnknown>;
}, "strip", z.ZodTypeAny, {
    name: string;
    appId: string;
    type: string;
    appName: string;
    description: string;
    displayName: string;
    payload: Record<string, unknown>;
    config: Record<string, unknown>;
    instructions?: string | undefined;
}, {
    name: string;
    appId: string;
    type: string;
    appName: string;
    description: string;
    displayName: string;
    payload: Record<string, unknown>;
    config: Record<string, unknown>;
    instructions?: string | undefined;
}>;

export type TriggerListParam = z.infer<typeof ZTriggerQuery> & {
    /** @deprecated use appUniqueKeys field instead */
    appNames?: string[];
};
export type TriggerSetupParam = z.infer<typeof ZTriggerSetupParam>;
export type TriggerInstanceItems = z.infer<typeof ZTriggerInstanceItems>;
type TriggerSubscribeParam$1 = z.infer<typeof ZTriggerSubscribeParam$1>;
export type SingleTriggerRes = z.infer<typeof ZSingleTriggerRes>;
export type TriggerSingleConfig = Pick<SingleTriggerRes, "config">;
export type TriggerListResponse = ListTriggersResponse;
export type TriggerSetupResponse = {
    status: string;
    /** @deprecated use triggerId field instead */
    triggerInstanceId: string;
    triggerId: string;
    triggerName: string;
};
export type SingleInstanceTriggerParam = z.infer<typeof ZTriggerInstanceParam> & {
    /** @deprecated use triggerId */
    triggerInstanceId?: string;
};
export declare class Triggers {
    trigger_to_client_event: string;
    private backendClient;
    private fileName;
    constructor(backendClient: AxiosBackendClient);
    /**
     * Retrieves a list of all triggers in the Composio platform.
     *
     * This method allows you to fetch a list of all the available triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {ListTriggersData} data The data for the request.
     * @returns {Promise<ListTriggersResponse>} A promise that resolves to the list of all triggers.
     * @throws {ComposioError} If the request fails.
     */
    list(data?: TriggerListParam): Promise<TriggerListResponse>;
    /**
     * Retrieves the configuration of a single trigger.
     *
     * @param {TriggerSingleParam} data The data for the request.
     * @returns {Promise<TriggerSingleConfig>} A promise that resolves to the trigger configuration.
     * @throws {ComposioError} If the request fails.
     */
    get(data: TriggerSingleParam): Promise<SingleTriggerRes>;
    /**
     * @deprecated use trigger.get instead
     * Retrieves the configuration of a single trigger.
     *
     * @param {TriggerSingleParam} data The data for the request.
     * @returns {Promise<TriggerSingleConfig>} A promise that resolves to the trigger configuration.
     * @throws {ComposioError} If the request fails.
     */
    getTriggerConfig(data: TriggerSingleParam): Promise<TriggerSingleConfig>;
    /**
     * Retrieves information about a single trigger.
     *
     * @param {TriggerSingleParam} data The data for the request.
     * @returns {Promise<SingleTriggerRes>} A promise that resolves to the trigger information.
     * @throws {ComposioError} If the request fails.
     */
    getTriggerInfo(data: TriggerSingleParam): Promise<SingleTriggerRes>;
    /**
     * Setup a trigger for a connected account.
     *
     * @param {SetupTriggerData} data The data for the request.
     * @returns {Promise<SetupTriggerResponse>} A promise that resolves to the setup trigger response.
     * @throws {ComposioError} If the request fails.
     */
    setup(params: TriggerSetupParam): Promise<TriggerSetupResponse>;
    /**
     * Enables a trigger for a connected account.
     *
     * @param {triggerId,triggerInstanceId} data The data for the request.
     * @returns {Promise<boolean>} A promise that resolves to the response of the enable request.
     * @throws {ComposioError} If the request fails.
     */
    enable(data: SingleInstanceTriggerParam): Promise<{
        status: string;
    }>;
    /**
     * Disables a trigger for a connected account.
     *
     * @param {triggerId,triggerInstanceId} data The data for the request.
     * @returns {Promise<boolean>} A promise that resolves to the response of the disable request.
     * @throws {ComposioError} If the request fails.
     */
    disable(data: SingleInstanceTriggerParam): Promise<{
        status: string;
    }>;
    /**
     * Deletes a trigger for a connected account.
     *
     * @param {TriggerInstanceItems} data The data for the request.
     * @returns {Promise<boolean>} A promise that resolves to the response of the delete request.
     * @throws {ComposioError} If the request fails.
     */
    delete(data: TriggerInstanceItems): Promise<{
        status: string;
    }>;
    subscribe(fn: (data: TriggerData) => void, filters?: TriggerSubscribeParam$1): Promise<void>;
    unsubscribe(): Promise<void>;
}

export declare const ZExecuteActionParams$1: z.ZodObject<{
    actionName: z.ZodString;
    params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    text: z.ZodOptional<z.ZodString>;
    connectedAccountId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    actionName: string;
    text?: string | undefined;
    params?: Record<string, any> | undefined;
    connectedAccountId?: string | undefined;
}, {
    actionName: string;
    text?: string | undefined;
    params?: Record<string, any> | undefined;
    connectedAccountId?: string | undefined;
}>;
export declare const ZInitiateConnectionParams: z.ZodObject<{
    appName: z.ZodOptional<z.ZodString>;
    authConfig: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    integrationId: z.ZodOptional<z.ZodString>;
    authMode: z.ZodOptional<z.ZodEnum<["OAUTH2", "OAUTH1", "OAUTH1A", "API_KEY", "BASIC", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "COMPOSIO_LINK"]>>;
    connectionParams: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    config: z.ZodOptional<z.ZodObject<{
        labels: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        redirectUrl: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    }, {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    }>>;
    redirectUri: z.ZodOptional<z.ZodString>;
    labels: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    authConfig?: Record<string, any> | undefined;
    integrationId?: string | undefined;
    appName?: string | undefined;
    labels?: string[] | undefined;
    config?: {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    } | undefined;
    authMode?: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | undefined;
    connectionParams?: Record<string, any> | undefined;
    redirectUri?: string | undefined;
}, {
    authConfig?: Record<string, any> | undefined;
    integrationId?: string | undefined;
    appName?: string | undefined;
    labels?: string[] | undefined;
    config?: {
        labels?: string[] | undefined;
        redirectUrl?: string | undefined;
    } | undefined;
    authMode?: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | undefined;
    connectionParams?: Record<string, any> | undefined;
    redirectUri?: string | undefined;
}>;
export declare const ZConnectionParams: z.ZodObject<{
    connectedAccountId: z.ZodOptional<z.ZodString>;
    app: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    app?: string | undefined;
    connectedAccountId?: string | undefined;
}, {
    app?: string | undefined;
    connectedAccountId?: string | undefined;
}>;
export declare const ZTriggerSubscribeParam: z.ZodObject<{
    app: z.ZodOptional<z.ZodString>;
    appName: z.ZodOptional<z.ZodString>;
    triggerName: z.ZodString;
    config: z.ZodRecord<z.ZodString, z.ZodAny>;
}, "strip", z.ZodTypeAny, {
    config: Record<string, any>;
    triggerName: string;
    appName?: string | undefined;
    app?: string | undefined;
}, {
    config: Record<string, any>;
    triggerName: string;
    appName?: string | undefined;
    app?: string | undefined;
}>;

export declare const ZActionGetParams: z.ZodObject<{
    actionName: z.ZodString;
}, "strip", z.ZodTypeAny, {
    actionName: string;
}, {
    actionName: string;
}>;
export declare const ZGetListActionsParams: z.ZodObject<{
    apps: z.ZodOptional<z.ZodString>;
    actions: z.ZodOptional<z.ZodString>;
    tags: z.ZodOptional<z.ZodString>;
    useCase: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    usecaseLimit: z.ZodOptional<z.ZodNumber>;
    showAll: z.ZodOptional<z.ZodBoolean>;
    showEnabledOnly: z.ZodOptional<z.ZodBoolean>;
    filterImportantActions: z.ZodOptional<z.ZodBoolean>;
    filterByAvailableApps: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    apps?: string | undefined;
    tags?: string | undefined;
    actions?: string | undefined;
    useCase?: string | null | undefined;
    usecaseLimit?: number | undefined;
    showAll?: boolean | undefined;
    showEnabledOnly?: boolean | undefined;
    filterImportantActions?: boolean | undefined;
    filterByAvailableApps?: boolean | undefined;
}, {
    apps?: string | undefined;
    tags?: string | undefined;
    actions?: string | undefined;
    useCase?: string | null | undefined;
    usecaseLimit?: number | undefined;
    showAll?: boolean | undefined;
    showEnabledOnly?: boolean | undefined;
    filterImportantActions?: boolean | undefined;
    filterByAvailableApps?: boolean | undefined;
}>;
export declare const ZExecuteParams: z.ZodObject<{
    actionName: z.ZodString;
    requestBody: z.ZodObject<{
        connectedAccountId: z.ZodOptional<z.ZodString>;
        input: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
        appName: z.ZodOptional<z.ZodString>;
        text: z.ZodOptional<z.ZodString>;
        authConfig: z.ZodOptional<z.ZodObject<{
            base_url: z.ZodOptional<z.ZodString>;
            parameters: z.ZodArray<z.ZodObject<{
                name: z.ZodString;
                in: z.ZodEnum<["query", "header"]>;
                value: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                name: string;
                value: string;
                in: "query" | "header";
            }, {
                name: string;
                value: string;
                in: "query" | "header";
            }>, "many">;
            body: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
        }, "strip", z.ZodTypeAny, {
            parameters: {
                name: string;
                value: string;
                in: "query" | "header";
            }[];
            base_url?: string | undefined;
            body?: Record<string, unknown> | undefined;
        }, {
            parameters: {
                name: string;
                value: string;
                in: "query" | "header";
            }[];
            base_url?: string | undefined;
            body?: Record<string, unknown> | undefined;
        }>>;
        allowTracing: z.ZodOptional<z.ZodBoolean>;
        sessionInfo: z.ZodOptional<z.ZodObject<{
            sessionId: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            sessionId?: string | undefined;
        }, {
            sessionId?: string | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        text?: string | undefined;
        authConfig?: {
            parameters: {
                name: string;
                value: string;
                in: "query" | "header";
            }[];
            base_url?: string | undefined;
            body?: Record<string, unknown> | undefined;
        } | undefined;
        appName?: string | undefined;
        connectedAccountId?: string | undefined;
        input?: Record<string, unknown> | undefined;
        allowTracing?: boolean | undefined;
        sessionInfo?: {
            sessionId?: string | undefined;
        } | undefined;
    }, {
        text?: string | undefined;
        authConfig?: {
            parameters: {
                name: string;
                value: string;
                in: "query" | "header";
            }[];
            base_url?: string | undefined;
            body?: Record<string, unknown> | undefined;
        } | undefined;
        appName?: string | undefined;
        connectedAccountId?: string | undefined;
        input?: Record<string, unknown> | undefined;
        allowTracing?: boolean | undefined;
        sessionInfo?: {
            sessionId?: string | undefined;
        } | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    actionName: string;
    requestBody: {
        text?: string | undefined;
        authConfig?: {
            parameters: {
                name: string;
                value: string;
                in: "query" | "header";
            }[];
            base_url?: string | undefined;
            body?: Record<string, unknown> | undefined;
        } | undefined;
        appName?: string | undefined;
        connectedAccountId?: string | undefined;
        input?: Record<string, unknown> | undefined;
        allowTracing?: boolean | undefined;
        sessionInfo?: {
            sessionId?: string | undefined;
        } | undefined;
    };
}, {
    actionName: string;
    requestBody: {
        text?: string | undefined;
        authConfig?: {
            parameters: {
                name: string;
                value: string;
                in: "query" | "header";
            }[];
            base_url?: string | undefined;
            body?: Record<string, unknown> | undefined;
        } | undefined;
        appName?: string | undefined;
        connectedAccountId?: string | undefined;
        input?: Record<string, unknown> | undefined;
        allowTracing?: boolean | undefined;
        sessionInfo?: {
            sessionId?: string | undefined;
        } | undefined;
    };
}>;
export declare const ZFindActionEnumsByUseCaseParams: z.ZodObject<{
    apps: z.ZodArray<z.ZodString, "many">;
    useCase: z.ZodString;
    limit: z.ZodOptional<z.ZodNumber>;
    filterByAvailableApps: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    apps: string[];
    useCase: string;
    filterByAvailableApps?: boolean | undefined;
    limit?: number | undefined;
}, {
    apps: string[];
    useCase: string;
    filterByAvailableApps?: boolean | undefined;
    limit?: number | undefined;
}>;
export declare const ZExecuteRequestParams: z.ZodObject<{
    connectedAccountId: z.ZodString;
    endpoint: z.ZodString;
    method: z.ZodEnum<["GET", "POST", "PUT", "PATCH", "DELETE"]>;
    parameters: z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        in: z.ZodEnum<["query", "header"]>;
        value: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        name: string;
        value: string;
        in: "query" | "header";
    }, {
        name: string;
        value: string;
        in: "query" | "header";
    }>, "many">;
    body: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}, "strip", z.ZodTypeAny, {
    connectedAccountId: string;
    parameters: {
        name: string;
        value: string;
        in: "query" | "header";
    }[];
    endpoint: string;
    method: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
    body?: Record<string, unknown> | undefined;
}, {
    connectedAccountId: string;
    parameters: {
        name: string;
        value: string;
        in: "query" | "header";
    }[];
    endpoint: string;
    method: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
    body?: Record<string, unknown> | undefined;
}>;

/**
 * Request types inferred from zod schemas
 */
export type ActionListParams = z.infer<typeof ZGetListActionsParams>;
export type ActionExecuteParam = z.infer<typeof ZExecuteParams>;
export type ActionItemParam = z.infer<typeof ZActionGetParams>;
export type FindActionEnumsByUseCaseParam = z.infer<typeof ZFindActionEnumsByUseCaseParams>;
export type ActionExecuteReqParam = z.infer<typeof ZExecuteRequestParams>;
export type ActionExecuteResponse = ActionExecutionResDto;
export type ActionFindActionEnumsByUseCaseRes = Array<string>;
export declare class Actions {
    private backendClient;
    fileName: string;
    constructor(backendClient: AxiosBackendClient);
    /**
     * Retrieves details of a specific action in the Composio platform by providing its action name.
     *
     * The response includes the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetActionData} data The data for the request.
     * @returns {Promise<ActionItemGetRes[0]>} A promise that resolves to the details of the action.
     * @throws {ComposioError} If the request fails.
     */
    get(data: ActionItemParam): Promise<ActionDetails>;
    /**
     * Retrieves a list of all actions in the Composio platform.
     *
     * This method allows you to fetch a list of all the available actions. It supports pagination to handle large numbers of actions. The response includes an array of action objects, each containing information such as the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetListActionsData} data The data for the request.
     * @returns {Promise<ActionsListResponseDTO>} A promise that resolves to the list of all actions.
     * @throws {ComposioError} If the request fails.
     */
    list(data?: ActionListParams): Promise<ActionsListResponseDTO>;
    /**
     * Executes a specific action in the Composio platform.
     * This doesn't execute the local action and is wrapper over backend. Try to call this method directly from toolset
     *
     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.
     *
     * @param {ExecuteActionData} data The data for the request.
     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the execution status and response data.
     * @throws {ComposioError} If the request fails.
     */
    execute(data: ActionExecuteParam): Promise<ActionExecuteResponse>;
    /**
     * Finds all action enums by use case.
     *
     * @param {FindActionEnumsByUseCaseParam} data The data for the request.
     * @returns {Promise<ActionFindActionEnumsByUseCaseRes>} A promise that resolves to the list of action enums.
     * @throws {ComposioError} If the request fails.
     */
    findActionEnumsByUseCase(data: FindActionEnumsByUseCaseParam): Promise<ActionFindActionEnumsByUseCaseRes>;
    /**
     * Executes a action using Composio Proxy
     *
     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.
     *
     * @param {ExecuteActionData} data The data for the request.
     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the execution status and response data.
     * @throws {ComposioError} If the request fails.
     */
    executeRequest(data: ActionExecuteReqParam): Promise<ActionExecuteResponse>;
}

export declare const ZListConnectionsData: z.ZodObject<{
    appNames: z.ZodOptional<z.ZodString>;
    appUniqueKeys: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    connectionId: z.ZodOptional<z.ZodString>;
    entityId: z.ZodOptional<z.ZodString>;
    integrationId: z.ZodOptional<z.ZodString>;
    labels: z.ZodOptional<z.ZodString>;
    page: z.ZodOptional<z.ZodNumber>;
    pageSize: z.ZodOptional<z.ZodNumber>;
    showActiveOnly: z.ZodOptional<z.ZodBoolean>;
    showDisabled: z.ZodOptional<z.ZodBoolean>;
    status: z.ZodOptional<z.ZodEnum<["INITIATED", "ACTIVE", "FAILED"]>>;
    user_uuid: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    status?: "FAILED" | "INITIATED" | "ACTIVE" | undefined;
    integrationId?: string | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
    showDisabled?: boolean | undefined;
    entityId?: string | undefined;
    labels?: string | undefined;
    connectionId?: string | undefined;
    appNames?: string | undefined;
    appUniqueKeys?: string[] | undefined;
    showActiveOnly?: boolean | undefined;
    user_uuid?: string | undefined;
}, {
    status?: "FAILED" | "INITIATED" | "ACTIVE" | undefined;
    integrationId?: string | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
    showDisabled?: boolean | undefined;
    entityId?: string | undefined;
    labels?: string | undefined;
    connectionId?: string | undefined;
    appNames?: string | undefined;
    appUniqueKeys?: string[] | undefined;
    showActiveOnly?: boolean | undefined;
    user_uuid?: string | undefined;
}>;
export declare const ZInitiateConnectionDataReq: z.ZodObject<{
    connectionParams: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
    entityId: z.ZodOptional<z.ZodString>;
    labels: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    integrationId: z.ZodOptional<z.ZodString>;
    redirectUri: z.ZodOptional<z.ZodString>;
    authMode: z.ZodOptional<z.ZodEnum<["OAUTH2", "OAUTH1", "OAUTH1A", "API_KEY", "BASIC", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "COMPOSIO_LINK"]>>;
    authConfig: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
    appName: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    authConfig?: Record<string, unknown> | undefined;
    integrationId?: string | undefined;
    appName?: string | undefined;
    entityId?: string | undefined;
    labels?: string[] | undefined;
    authMode?: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | undefined;
    connectionParams?: Record<string, unknown> | undefined;
    redirectUri?: string | undefined;
}, {
    authConfig?: Record<string, unknown> | undefined;
    integrationId?: string | undefined;
    appName?: string | undefined;
    entityId?: string | undefined;
    labels?: string[] | undefined;
    authMode?: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | undefined;
    connectionParams?: Record<string, unknown> | undefined;
    redirectUri?: string | undefined;
}>;
export declare const ZSaveUserAccessDataParam: z.ZodObject<{
    fieldInputs: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    redirectUrl: z.ZodOptional<z.ZodString>;
    entityId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    fieldInputs: Record<string, unknown>;
    entityId?: string | undefined;
    redirectUrl?: string | undefined;
}, {
    fieldInputs: Record<string, unknown>;
    entityId?: string | undefined;
    redirectUrl?: string | undefined;
}>;
export declare const ZSingleConnectionParams: z.ZodObject<{
    connectedAccountId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    connectedAccountId: string;
}, {
    connectedAccountId: string;
}>;
export declare const ZReinitiateConnectionPayloadDto: z.ZodObject<{
    connectedAccountId: z.ZodString;
    data: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    redirectUri: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    connectedAccountId: string;
    data: Record<string, unknown>;
    redirectUri?: string | undefined;
}, {
    connectedAccountId: string;
    data: Record<string, unknown>;
    redirectUri?: string | undefined;
}>;

export type ConnectedAccountsListData = z.infer<typeof ZListConnectionsData> & {
    /** @deprecated use appUniqueKeys field instead */
    appNames?: string;
};
export type InitiateConnectionDataReq = z.infer<typeof ZInitiateConnectionDataReq>;
export type SingleConnectionParam = z.infer<typeof ZSingleConnectionParams>;
export type SaveUserAccessDataParam = z.infer<typeof ZSaveUserAccessDataParam>;
export type ReinitiateConnectionPayload = z.infer<typeof ZReinitiateConnectionPayloadDto>;
export type ConnectedAccountListResponse = GetConnectionsResponseDto;
export type SingleConnectedAccountResponse = ConnectedAccountResponseDTO;
export type SingleDeleteResponse = DeleteRowAPIDTO;
export type ConnectionChangeResponse = {
    status: "success";
    connectedAccountId: string;
};
export type ConnectionItem = ConnectionParams$1;
/**
 * Class representing connected accounts in the system.
 */
export declare class ConnectedAccounts {
    private backendClient;
    private fileName;
    /**
     * Initializes a new instance of the ConnectedAccounts class.
     * @param {AxiosBackendClient} backendClient - The backend client instance.
     */
    constructor(backendClient: AxiosBackendClient);
    /**
     * List all connected accounts
     * @param {ConnectedAccountsListData} data - The data for the connected accounts list
     * @returns {Promise<ConnectedAccountListResponse>} - A promise that resolves to a list of connected accounts
     */
    list(data: ConnectedAccountsListData): Promise<ConnectedAccountListResponse>;
    /**
     * Get a single connected account
     * @param {SingleConnectionParam} data - The data for the single connection
     * @returns {Promise<SingleConnectedAccountResponse>} - A promise that resolves to a single connected account
     */
    get(data: SingleConnectionParam): Promise<SingleConnectedAccountResponse>;
    /**
     * Delete a single connected account
     * @param {SingleConnectionParam} data - The data for the single connection
     * @returns {Promise<SingleDeleteResponse>} - A promise that resolves when the connected account is deleted
     */
    delete(data: SingleConnectionParam): Promise<SingleDeleteResponse>;
    /**
     * Disable a single connected account
     * @param {SingleConnectionParam} data - The data for the single connection
     * @returns {Promise<ConnectionChangeResponse>} - A promise that resolves when the connected account is disabled
     */
    disable(data: SingleConnectionParam): Promise<ConnectionChangeResponse>;
    /**
     * Enable a single connected account
     * @param {SingleConnectionParam} data - The data for the single connection
     * @returns {Promise<ConnectionChangeResponse>} - A promise that resolves when the connected account is enabled
     */
    enable(data: SingleConnectionParam): Promise<ConnectionChangeResponse>;
    /**
     * Initiate a connection
     * @param {InitiateConnectionDataReq} payload - The payload for the connection initiation
     * @returns {Promise<ConnectionRequest>} - A promise that resolves to a connection request
     */
    initiate(payload: InitiateConnectionDataReq): Promise<ConnectionRequest>;
    /**
     * Reinitiate a connection
     * @param {ReinitiateConnectionPayload} data - The payload for the connection reinitialization
     * @returns {Promise<ConnectionRequest>} - A promise that resolves to a connection request
     */
    reinitiateConnection(data: ReinitiateConnectionPayload): Promise<ConnectionRequest>;
}
export declare class ConnectionRequest {
    connectionStatus: string;
    connectedAccountId: string;
    redirectUrl: string | null;
    constructor({ connectionStatus, connectedAccountId, redirectUri, }: {
        connectionStatus: string;
        connectedAccountId: string;
        redirectUri: string | null;
    });
    saveUserAccessData(data: SaveUserAccessDataParam): Promise<(axios.AxiosResponse<InitiateConnectionResponse, any> & {
        error: undefined;
    }) | (axios.AxiosError<InitiateConnectionError, any> & {
        data: undefined;
        error: InitiateConnectionError;
    })>;
    /**
     * Wait until the connection becomes active
     * @param {number} timeout - The timeout for the connection to become active
     * @returns {Promise<Connection>} - A promise that resolves to the connection
     */
    waitUntilActive(timeout?: number): Promise<ConnectedAccountResponseDTO>;
}

export type TriggerSubscribeParam = z.infer<typeof ZTriggerSubscribeParam>;
export type ConnectionParams = z.infer<typeof ZConnectionParams> & {
    /** @deprecated use appName field instead */
    app?: string;
    appName?: string;
};
export type InitiateConnectionParams = z.infer<typeof ZInitiateConnectionParams>;
type ExecuteActionParams$1 = z.infer<typeof ZExecuteActionParams$1>;
export declare class Entity {
    id: string;
    private backendClient;
    private triggerModel;
    private actionsModel;
    private apps;
    private connectedAccounts;
    private integrations;
    private activeTriggers;
    private fileName;
    constructor(backendClient: AxiosBackendClient, id?: string);
    /**
     * Executes an action for an entity.
     *
     * @param {string} actionName The name of the action to execute.
     * @param {Record<string, unknown>} params The parameters for the action.
     * @param {string} text The text to pass to the action. This can be to perform NLA execution
     * @param {string} connectedAccountId The ID of the connected account to use for the action.
     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the response from the action execution.
     * @throws {ComposioError} If the request fails.
     */
    execute({ actionName, params, text, connectedAccountId, }: ExecuteActionParams$1): Promise<ActionExecuteResponse>;
    /**
     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.
     *
     * This method allows clients to fetch the necessary parameters for a specific authentication scheme of an app by providing its unique key and the authentication scheme.
     *
     * @param {ConnectionParams} data The data for the request, including the app's unique key and the authentication scheme.
     * @returns {Promise<RequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.
     * @throws {ComposioError} If the request fails.
     */
    getConnection({ app, appName, connectedAccountId }: ConnectionParams): Promise<ConnectedAccountResponseDTO>;
    /**
     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.
     *
     * This method allows clients to setup a trigger for an app by providing its unique key and the trigger name.
     *
     * @param {TriggerSubscribeParam} data The data for the request, including the app's unique key and the trigger name.
     * @returns {Promise<RequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.
     * @throws {ComposioError} If the request fails.
     */
    setupTrigger({ app, appName, triggerName, config, }: TriggerSubscribeParam): Promise<TriggerSetupResponse>;
    /**
     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.
     *
     * This method allows clients to disable a trigger by providing its trigger ID.
     *
     * @param {string} triggerId The ID of the trigger to disable.
     * @returns {Promise<{ status: string }>} A promise that resolves to the status of the trigger disablement.
     * @throws {ComposioError} If the request fails.
     */
    disableTrigger(triggerId: string): Promise<{
        status: string;
    }>;
    /**
     * Retrieves all connections for an entity.
     *
     * @returns {Promise<ConnectionItem[]>} A promise that resolves to an array of connection items.
     * @throws {ComposioError} If the request fails.
     */
    getConnections(): Promise<ConnectionItem[]>;
    /**
     * Retrieves all active triggers for an entity.
     *
     * @returns {Promise<ActiveTrigger[]>} A promise that resolves to an array of active triggers.
     * @throws {ComposioError} If the request fails.
     */
    getActiveTriggers(): Promise<{
        id: string;
        createdAt: string;
        updatedAt: string;
        connectionId: string;
        triggerName: string;
        triggerConfig: Record<string, unknown>;
        triggerData: string;
        state: Record<string, unknown>;
        connection: {
            id: string;
            status: string;
            integrationId: string;
            createdAt: string;
            updatedAt: string;
            memberId: string;
            enabled: boolean;
            clientUniqueUserId: string;
            data: Record<string, unknown>;
            labels: unknown[];
            deleted?: boolean | undefined;
        };
        disabledAt: string | null;
        disabledReason: string | null;
    }[]>;
    /**
     * Initiate a connection for an entity.
     * @param {InitiateConnectionParams} data The data for the request, including the app's unique key and the authentication scheme.
     * @returns {Promise<ConnectionRequest>} A promise that resolves to the connection request.
     * @throws {ComposioError} If the request fails.
     */
    initiateConnection(data: InitiateConnectionParams): Promise<ConnectionRequest>;
}

export declare const ZGetExpectedParamsForUserParams: z.ZodObject<{
    app: z.ZodOptional<z.ZodString>;
    integrationId: z.ZodOptional<z.ZodString>;
    entityId: z.ZodOptional<z.ZodString>;
    authScheme: z.ZodOptional<z.ZodEnum<["OAUTH2", "OAUTH1", "OAUTH1A", "API_KEY", "BASIC", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "COMPOSIO_LINK"]>>;
}, "strip", z.ZodTypeAny, {
    authScheme?: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | undefined;
    integrationId?: string | undefined;
    app?: string | undefined;
    entityId?: string | undefined;
}, {
    authScheme?: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | undefined;
    integrationId?: string | undefined;
    app?: string | undefined;
    entityId?: string | undefined;
}>;
export declare const ZGetExpectedParamsRes: z.ZodObject<{
    expectedInputFields: z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        type: z.ZodString;
        description: z.ZodString;
        display_name: z.ZodString;
        default: z.ZodRecord<z.ZodString, z.ZodUnknown>;
        required: z.ZodBoolean;
        expected_from_customer: z.ZodBoolean;
        is_secret: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        name: string;
        type: string;
        description: string;
        display_name: string;
        default: Record<string, unknown>;
        required: boolean;
        expected_from_customer: boolean;
        is_secret: boolean;
    }, {
        name: string;
        type: string;
        description: string;
        display_name: string;
        default: Record<string, unknown>;
        required: boolean;
        expected_from_customer: boolean;
        is_secret: boolean;
    }>, "many">;
    integrationId: z.ZodString;
    authScheme: z.ZodEnum<["OAUTH2", "OAUTH1", "OAUTH1A", "API_KEY", "BASIC", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "COMPOSIO_LINK"]>;
}, "strip", z.ZodTypeAny, {
    authScheme: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK";
    integrationId: string;
    expectedInputFields: {
        name: string;
        type: string;
        description: string;
        display_name: string;
        default: Record<string, unknown>;
        required: boolean;
        expected_from_customer: boolean;
        is_secret: boolean;
    }[];
}, {
    authScheme: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK";
    integrationId: string;
    expectedInputFields: {
        name: string;
        type: string;
        description: string;
        display_name: string;
        default: Record<string, unknown>;
        required: boolean;
        expected_from_customer: boolean;
        is_secret: boolean;
    }[];
}>;

export declare const ZTriggerItemParam: z.ZodObject<{
    triggerId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    triggerId: string;
}, {
    triggerId: string;
}>;
export declare const ZActiveTriggersQuery: z.ZodObject<{
    triggerIds: z.ZodOptional<z.ZodString>;
    triggerNames: z.ZodOptional<z.ZodString>;
    connectedAccountIds: z.ZodOptional<z.ZodString>;
    integrationIds: z.ZodOptional<z.ZodString>;
    limit: z.ZodOptional<z.ZodNumber>;
    page: z.ZodOptional<z.ZodNumber>;
    showDisabled: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    page?: number | undefined;
    showDisabled?: boolean | undefined;
    limit?: number | undefined;
    triggerIds?: string | undefined;
    triggerNames?: string | undefined;
    connectedAccountIds?: string | undefined;
    integrationIds?: string | undefined;
}, {
    page?: number | undefined;
    showDisabled?: boolean | undefined;
    limit?: number | undefined;
    triggerIds?: string | undefined;
    triggerNames?: string | undefined;
    connectedAccountIds?: string | undefined;
    integrationIds?: string | undefined;
}>;
export declare const ZActiveTriggerItemRes: z.ZodObject<{
    id: z.ZodString;
    connectionId: z.ZodString;
    triggerName: z.ZodString;
    triggerData: z.ZodString;
    triggerConfig: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    state: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    createdAt: z.ZodString;
    updatedAt: z.ZodString;
    disabledAt: z.ZodNullable<z.ZodString>;
    disabledReason: z.ZodNullable<z.ZodString>;
    connection: z.ZodObject<{
        id: z.ZodString;
        integrationId: z.ZodString;
        memberId: z.ZodString;
        clientUniqueUserId: z.ZodString;
        status: z.ZodString;
        data: z.ZodRecord<z.ZodString, z.ZodUnknown>;
        deleted: z.ZodOptional<z.ZodBoolean>;
        enabled: z.ZodBoolean;
        labels: z.ZodArray<z.ZodUnknown, "many">;
        createdAt: z.ZodString;
        updatedAt: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        id: string;
        status: string;
        integrationId: string;
        createdAt: string;
        updatedAt: string;
        memberId: string;
        enabled: boolean;
        clientUniqueUserId: string;
        data: Record<string, unknown>;
        labels: unknown[];
        deleted?: boolean | undefined;
    }, {
        id: string;
        status: string;
        integrationId: string;
        createdAt: string;
        updatedAt: string;
        memberId: string;
        enabled: boolean;
        clientUniqueUserId: string;
        data: Record<string, unknown>;
        labels: unknown[];
        deleted?: boolean | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    id: string;
    createdAt: string;
    updatedAt: string;
    connectionId: string;
    triggerName: string;
    triggerConfig: Record<string, unknown>;
    triggerData: string;
    state: Record<string, unknown>;
    connection: {
        id: string;
        status: string;
        integrationId: string;
        createdAt: string;
        updatedAt: string;
        memberId: string;
        enabled: boolean;
        clientUniqueUserId: string;
        data: Record<string, unknown>;
        labels: unknown[];
        deleted?: boolean | undefined;
    };
    disabledAt: string | null;
    disabledReason: string | null;
}, {
    id: string;
    createdAt: string;
    updatedAt: string;
    connectionId: string;
    triggerName: string;
    triggerConfig: Record<string, unknown>;
    triggerData: string;
    state: Record<string, unknown>;
    connection: {
        id: string;
        status: string;
        integrationId: string;
        createdAt: string;
        updatedAt: string;
        memberId: string;
        enabled: boolean;
        clientUniqueUserId: string;
        data: Record<string, unknown>;
        labels: unknown[];
        deleted?: boolean | undefined;
    };
    disabledAt: string | null;
    disabledReason: string | null;
}>;

export type TriggerItemParam = z.infer<typeof ZTriggerItemParam>;
export type GetActiveTriggersData = z.infer<typeof ZActiveTriggersQuery>;
export type TriggerItemRes = z.infer<typeof ZActiveTriggerItemRes>;
export type TriggerChangeResponse = {
    status: string;
};
export declare class ActiveTriggers {
    private backendClient;
    private fileName;
    constructor(backendClient: AxiosBackendClient);
    /** Missing type */
    /**
     * Retrieves details of a specific active trigger in the Composio platform by providing its trigger name.
     *
     * The response includes the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {TriggerItemParam} data The data for the request.
     * @returns {Promise<TriggerItemRes>} A promise that resolves to the details of the active trigger.
     * @throws {ComposioError} If the request fails.
     */
    get({ triggerId }: TriggerItemParam): Promise<{
        id: string;
        createdAt: string;
        updatedAt: string;
        connectionId: string;
        triggerName: string;
        triggerConfig: Record<string, unknown>;
        triggerData: string;
        state: Record<string, unknown>;
        connection: {
            id: string;
            status: string;
            integrationId: string;
            createdAt: string;
            updatedAt: string;
            memberId: string;
            enabled: boolean;
            clientUniqueUserId: string;
            data: Record<string, unknown>;
            labels: unknown[];
            deleted?: boolean | undefined;
        };
        disabledAt: string | null;
        disabledReason: string | null;
    }>;
    /**
     * Retrieves a list of all active triggers in the Composio platform.
     *
     * This method allows you to fetch a list of all the available active triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {GetActiveTriggersData} data The data for the request.
     * @returns {Promise<ZActiveTriggerItemRes[]>} A promise that resolves to the list of all active triggers.
     * @throws {ComposioError} If the request fails.
     */
    list(data?: GetActiveTriggersData): Promise<TriggerItemRes[]>;
    /**
     * Enables the previously disabled trigger.
     *
     * @param {TriggerItemParam} data The data for the request.
     * @returns {Promise<{status: string}>} A promise that resolves to the response of the enable request.
     * @throws {ComposioError} If the request fails.
     */
    enable(data: TriggerItemParam): Promise<{
        status: string;
    }>;
    /**
     * Disables the previously enabled trigger.
     *
     * @param {TriggerItemParam} data The data for the request.
     * @returns {Promise<{status: string}>} A promise that resolves to the response of the disable request.
     */
    disable(data: TriggerItemParam): Promise<TriggerChangeResponse>;
}

export declare const ZGetAppParams: z.ZodObject<{
    appKey: z.ZodString;
}, "strip", z.ZodTypeAny, {
    appKey: string;
}, {
    appKey: string;
}>;
export declare const ZGetRequiredParamsForAuthScheme: z.ZodObject<{
    appId: z.ZodString;
    authScheme: z.ZodString;
}, "strip", z.ZodTypeAny, {
    authScheme: string;
    appId: string;
}, {
    authScheme: string;
    appId: string;
}>;
export declare const ZRequiredParamsResponse: z.ZodObject<{
    required_fields: z.ZodArray<z.ZodString, "many">;
    expected_from_user: z.ZodArray<z.ZodString, "many">;
    optional_fields: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    required_fields: string[];
    expected_from_user: string[];
    optional_fields: string[];
}, {
    required_fields: string[];
    expected_from_user: string[];
    optional_fields: string[];
}>;
export declare const ZRequiredParamsFullResponse: z.ZodObject<{
    availableAuthSchemes: z.ZodArray<z.ZodString, "many">;
    authSchemes: z.ZodRecord<z.ZodString, z.ZodObject<{
        required_fields: z.ZodArray<z.ZodString, "many">;
        expected_from_user: z.ZodArray<z.ZodString, "many">;
        optional_fields: z.ZodArray<z.ZodString, "many">;
    }, "strip", z.ZodTypeAny, {
        required_fields: string[];
        expected_from_user: string[];
        optional_fields: string[];
    }, {
        required_fields: string[];
        expected_from_user: string[];
        optional_fields: string[];
    }>>;
}, "strip", z.ZodTypeAny, {
    availableAuthSchemes: string[];
    authSchemes: Record<string, {
        required_fields: string[];
        expected_from_user: string[];
        optional_fields: string[];
    }>;
}, {
    availableAuthSchemes: string[];
    authSchemes: Record<string, {
        required_fields: string[];
        expected_from_user: string[];
        optional_fields: string[];
    }>;
}>;

export type AppGetRequiredParamsForAuthSchemeParam = z.infer<typeof ZGetRequiredParamsForAuthScheme> & {
    appName?: string;
    /**
     * @deprecated use appName instead
     */
    appId?: string;
};
export type AppRequiredParamsFullResponse = z.infer<typeof ZRequiredParamsFullResponse>;
export type AppRequiredParamsResponse = z.infer<typeof ZRequiredParamsResponse>;
export type AppGetDataParams = z.infer<typeof ZGetAppParams>;
export type AppItemResponse = SingleAppInfoResDTO;
export type AppListResponse = AppItemListResponse[];
export type AppItemListResponse = AppInfoResponseDto;
export declare class Apps {
    private backendClient;
    private fileName;
    constructor(backendClient: AxiosBackendClient);
    /**
     * Retrieves a list of all available apps in the Composio platform.
     *
     * This method allows clients to explore and discover the supported apps. It returns an array of app objects, each containing essential details such as the app's key, name, description, logo, categories, and unique identifier.
     *
     * @returns {Promise<AppItemListResponse[]>} A promise that resolves to the list of all apps.
     * @throws {ComposioError} If the request fails.
     */
    list(): Promise<AppListResponse>;
    /**
     * Retrieves details of a specific app in the Composio platform.
     *
     * This method allows clients to fetch detailed information about a specific app by providing its unique key. The response includes the app's name, key, status, description, logo, categories, authentication schemes, and other metadata.
     *
     * @param {AppGetDataParams} data The data for the request, including the app's unique key.
     * @returns {Promise<AppItemResponse>} A promise that resolves to the details of the app.
     * @throws {ComposioError} If the request fails.
     */
    get(data: AppGetDataParams): Promise<AppItemResponse>;
    /**
     * Retrieves the required parameters for a specific app in the Composio platform.
     *
     * This method allows clients to fetch the necessary parameters for a specific app by providing its unique key. The response includes the app's name, key, status, description, logo, categories, authentication schemes, and other metadata.
     *
     * @param {string} appId The unique key of the app.
     * @returns {Promise<AppRequiredParamsFullResponse>} A promise that resolves to the required parameters for the app.
     * @throws {ComposioError} If the request fails.
     */
    getRequiredParams(appId: string): Promise<AppRequiredParamsFullResponse>;
    /**
     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.
     *
     * This method allows clients to fetch the necessary parameters for a specific authentication scheme of an app by providing its unique key and the authentication scheme.
     *
     * @param {AppGetRequiredParamsForAuthSchemeParam} data The data for the request, including the app's unique key and the authentication scheme.
     * @returns {Promise<AppRequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.
     * @throws {ComposioError} If the request fails.
     */
    getRequiredParamsForAuthScheme({ appId, appName, authScheme, }: AppGetRequiredParamsForAuthSchemeParam): Promise<AppRequiredParamsResponse>;
}

export declare const ZCreateIntegrationParams: z.ZodObject<{
    name: z.ZodString;
    authScheme: z.ZodOptional<z.ZodEnum<["OAUTH2", "OAUTH1", "OAUTH1A", "API_KEY", "BASIC", "BEARER_TOKEN", "GOOGLE_SERVICE_ACCOUNT", "NO_AUTH", "BASIC_WITH_JWT", "COMPOSIO_LINK"]>>;
    appUniqueKey: z.ZodOptional<z.ZodString>;
    appId: z.ZodOptional<z.ZodString>;
    forceNewIntegration: z.ZodOptional<z.ZodBoolean>;
    authConfig: z.ZodOptional<z.ZodUnion<[z.ZodRecord<z.ZodString, z.ZodUnknown>, z.ZodObject<{
        client_id: z.ZodString;
        client_secret: z.ZodString;
        api_key: z.ZodString;
        consumer_key: z.ZodString;
        consumer_secret: z.ZodString;
        base_url: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        client_id: string;
        client_secret: string;
        api_key: string;
        consumer_key: string;
        consumer_secret: string;
        base_url: string;
    }, {
        client_id: string;
        client_secret: string;
        api_key: string;
        consumer_key: string;
        consumer_secret: string;
        base_url: string;
    }>]>>;
    useComposioAuth: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    name: string;
    authScheme?: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | undefined;
    appUniqueKey?: string | undefined;
    appId?: string | undefined;
    forceNewIntegration?: boolean | undefined;
    authConfig?: Record<string, unknown> | {
        client_id: string;
        client_secret: string;
        api_key: string;
        consumer_key: string;
        consumer_secret: string;
        base_url: string;
    } | undefined;
    useComposioAuth?: boolean | undefined;
}, {
    name: string;
    authScheme?: "OAUTH2" | "OAUTH1" | "OAUTH1A" | "API_KEY" | "BASIC" | "BEARER_TOKEN" | "GOOGLE_SERVICE_ACCOUNT" | "NO_AUTH" | "BASIC_WITH_JWT" | "COMPOSIO_LINK" | undefined;
    appUniqueKey?: string | undefined;
    appId?: string | undefined;
    forceNewIntegration?: boolean | undefined;
    authConfig?: Record<string, unknown> | {
        client_id: string;
        client_secret: string;
        api_key: string;
        consumer_key: string;
        consumer_secret: string;
        base_url: string;
    } | undefined;
    useComposioAuth?: boolean | undefined;
}>;
export declare const ZSingleIntegrationParams: z.ZodObject<{
    integrationId: z.ZodString;
}, "strip", z.ZodTypeAny, {
    integrationId: string;
}, {
    integrationId: string;
}>;
export declare const ZListIntegrationsParams: z.ZodObject<{
    page: z.ZodOptional<z.ZodNumber>;
    pageSize: z.ZodOptional<z.ZodNumber>;
    appName: z.ZodOptional<z.ZodString>;
    appUniqueKey: z.ZodOptional<z.ZodString>;
    showDisabled: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    appUniqueKey?: string | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
    appName?: string | undefined;
    showDisabled?: boolean | undefined;
}, {
    appUniqueKey?: string | undefined;
    page?: number | undefined;
    pageSize?: number | undefined;
    appName?: string | undefined;
    showDisabled?: boolean | undefined;
}>;

export type IntegrationGetRequiredParam = z.infer<typeof ZSingleIntegrationParams>;
export type IntegrationCreateParams = z.infer<typeof ZCreateIntegrationParams> & {
    /** @deprecated use appUniqueKey field instead */
    appId?: string;
};
export type IntegrationListParam = z.infer<typeof ZListIntegrationsParams> & {
    /** @deprecated use appUniqueKeys field instead */
    appName?: string;
};
export type IntegrationDeleteParam = z.infer<typeof ZSingleIntegrationParams>;
export type IntegrationListRes = GetConnectorListResDTO;
export type IntegrationGetRes = GetConnectorInfoResDTO;
export type IntegrationRequiredParamsRes = ExpectedInputFieldsDTO[];
export type IntegrationDeleteRes = DeleteRowAPIDTO;
export declare class Integrations {
    private backendClient;
    private fileName;
    private apps;
    constructor(backendClient: AxiosBackendClient);
    /**
     * Retrieves a list of all available integrations in the Composio platform.
     *
     * This method allows clients to explore and discover the supported integrations. It returns an array of integration objects, each containing essential details such as the integration's key, name, description, logo, categories, and unique identifier.
     *
     * @returns {Promise<IntegrationListRes>} A promise that resolves to the list of all integrations.
     * @throws {ComposioError} If the request fails.
     */
    list(data?: IntegrationListParam): Promise<IntegrationListRes>;
    /**
     * Retrieves details of a specific integration in the Composio platform by providing its integration name.
     *
     * The response includes the integration's name, display name, description, input parameters, expected response, associated app information, and enabled status.
     *
     * @param {IntegrationGetParam} data The data for the request.
     * @returns {Promise<IntegrationGetResponse>} A promise that resolves to the details of the integration.
     * @throws {ComposioError} If the request fails.
     */
    get(data: IntegrationGetRequiredParam): Promise<IntegrationGetRes>;
    /**
     * Retrieves the required parameters for a specific integration's authentication scheme.
     *
     * This method is used to get the necessary input fields for a specific integration's authentication scheme.
     *
     * @param {IntegrationGetParam} data The data for the request.
     * @returns {Promise<IntegrationRequiredParamsRes>} A promise that resolves to the required parameters for the integration's authentication scheme.
     * @throws {ComposioError} If the request fails.
     */
    getRequiredParams(data: IntegrationGetRequiredParam): Promise<IntegrationRequiredParamsRes>;
    /**
     * Creates a new integration in the Composio platform.
     *
     * This method allows clients to create a new integration by providing the necessary details such as app ID, name, authentication mode, and configuration.
     *
     * @param {IntegrationCreateParams} data The data for the request.
     * @returns {Promise<IntegrationGetResponse>} A promise that resolves to the created integration model.
     * @throws {ComposioError} If the request fails.
     */
    create(data: IntegrationCreateParams): Promise<IntegrationGetRes>;
    getOrCreateIntegration(data: IntegrationCreateParams): Promise<IntegrationGetRes>;
    /**
     * Deletes an existing integration in the Composio platform.
     *
     * This method allows clients to delete an existing integration by providing its integration ID.
     *
     * @param {IntegrationListData} data The data for the request.
     * @returns {Promise<IntegrationDeleteResponse>} A promise that resolves to the deleted integration model.
     * @throws {ComposioError} If the request fails.
     */
    delete(data: IntegrationDeleteParam): Promise<IntegrationDeleteRes>;
}

export type ComposioInputFieldsParams = z.infer<typeof ZGetExpectedParamsForUserParams>;
export type ComposioInputFieldsRes = z.infer<typeof ZGetExpectedParamsRes>;
export declare class Composio {
    /**
     * The Composio class serves as the main entry point for interacting with the Composio SDK.
     * It provides access to various models that allow for operations on connected accounts, apps,
     * actions, triggers, integrations, and active triggers.
     */
    backendClient: AxiosBackendClient;
    connectedAccounts: ConnectedAccounts;
    apps: Apps;
    actions: Actions;
    triggers: Triggers;
    integrations: Integrations;
    activeTriggers: ActiveTriggers;
    fileName: string;
    /**
     * Initializes a new instance of the Composio class.
     *
     * @param {Object} config - Configuration object for the Composio SDK
     * @param {string} [config.apiKey] - The API key for authenticating with the Composio backend. Can also be set locally in an environment variable.
     * @param {string} [config.baseUrl] - The base URL for the Composio backend. By default, it is set to the production URL.
     * @param {string} [config.runtime] - The runtime environment for the SDK.
     * @param {boolean} [config.allowTracing] - Whether to allow tracing for the SDK.
     */
    constructor(config?: {
        apiKey?: string;
        baseUrl?: string;
        runtime?: string;
        allowTracing?: boolean;
    });
    /**
     * Checks for the latest version of the Composio SDK from NPM.
     * If a newer version is available, it logs a warning to the console.
     */
    private checkForLatestVersionFromNPM;
    /**
     * Retrieves an Entity instance associated with a given ID.
     *
     * @param {string} [id='default'] - The ID of the entity to retrieve.
     * @returns {Entity} An instance of the Entity class.
     */
    getEntity(id?: string): Entity;
    getExpectedParamsForUser(params: ComposioInputFieldsParams): Promise<ComposioInputFieldsRes>;
}

export declare const ZRawActionSchema: z.ZodObject<{
    name: z.ZodString;
    display_name: z.ZodString;
    description: z.ZodString;
    appKey: z.ZodString;
    appId: z.ZodString;
    appName: z.ZodString;
    logo: z.ZodString;
    enabled: z.ZodBoolean;
    tags: z.ZodArray<z.ZodString, "many">;
    parameters: z.ZodObject<{
        type: z.ZodString;
        title: z.ZodString;
        description: z.ZodString;
        required: z.ZodArray<z.ZodString, "many">;
        properties: z.ZodRecord<z.ZodString, z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        type: string;
        description: string;
        required: string[];
        properties: Record<string, any>;
        title: string;
    }, {
        type: string;
        description: string;
        required: string[];
        properties: Record<string, any>;
        title: string;
    }>;
    response: z.ZodRecord<z.ZodString, z.ZodAny>;
    metadata: z.ZodObject<{
        name: z.ZodString;
        toolName: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        toolName?: string | undefined;
    }, {
        name: string;
        toolName?: string | undefined;
    }>;
}, "strip", z.ZodTypeAny, {
    metadata: {
        name: string;
        toolName?: string | undefined;
    };
    name: string;
    appId: string;
    appName: string;
    description: string;
    display_name: string;
    logo: string;
    enabled: boolean;
    parameters: {
        type: string;
        description: string;
        required: string[];
        properties: Record<string, any>;
        title: string;
    };
    appKey: string;
    tags: string[];
    response: Record<string, any>;
}, {
    metadata: {
        name: string;
        toolName?: string | undefined;
    };
    name: string;
    appId: string;
    appName: string;
    description: string;
    display_name: string;
    logo: string;
    enabled: boolean;
    parameters: {
        type: string;
        description: string;
        required: string[];
        properties: Record<string, any>;
        title: string;
    };
    appKey: string;
    tags: string[];
    response: Record<string, any>;
}>;
export type RawActionData = z.infer<typeof ZRawActionSchema>;
export declare const ZExecuteActionParams: z.ZodObject<{
    action: z.ZodString;
    params: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    entityId: z.ZodOptional<z.ZodString>;
    nlaText: z.ZodOptional<z.ZodString>;
    connectedAccountId: z.ZodOptional<z.ZodString>;
    config: z.ZodOptional<z.ZodObject<{
        labels: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        labels?: string[] | undefined;
    }, {
        labels?: string[] | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    action: string;
    params?: Record<string, any> | undefined;
    entityId?: string | undefined;
    connectedAccountId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
    } | undefined;
    nlaText?: string | undefined;
}, {
    action: string;
    params?: Record<string, any> | undefined;
    entityId?: string | undefined;
    connectedAccountId?: string | undefined;
    config?: {
        labels?: string[] | undefined;
    } | undefined;
    nlaText?: string | undefined;
}>;
export type TPreProcessor = ({ params, }: {
    params: Record<string, unknown>;
    actionName: string;
}) => Promise<Record<string, unknown>> | Record<string, unknown>;
export type TPostProcessor = ({ actionName, toolResponse, }: {
    actionName: string;
    toolResponse: ActionExecutionResDto;
}) => Promise<ActionExecutionResDto> | ActionExecutionResDto;
export type TSchemaProcessor = ({ actionName, toolSchema, }: {
    actionName: string;
    toolSchema: RawActionData;
}) => Promise<RawActionData> | RawActionData;
export declare const ZToolSchemaFilter: z.ZodObject<{
    actions: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    apps: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    tags: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    useCase: z.ZodOptional<z.ZodString>;
    useCaseLimit: z.ZodOptional<z.ZodNumber>;
    filterByAvailableApps: z.ZodOptional<z.ZodBoolean>;
    integrationId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    apps?: string[] | undefined;
    integrationId?: string | undefined;
    tags?: string[] | undefined;
    actions?: string[] | undefined;
    useCase?: string | undefined;
    filterByAvailableApps?: boolean | undefined;
    useCaseLimit?: number | undefined;
}, {
    apps?: string[] | undefined;
    integrationId?: string | undefined;
    tags?: string[] | undefined;
    actions?: string[] | undefined;
    useCase?: string | undefined;
    filterByAvailableApps?: boolean | undefined;
    useCaseLimit?: number | undefined;
}>;

type Optional$1<T> = T | null;
type Sequence<T> = Array<T>;

export type RawExecuteRequestParam = {
    connectedAccountId?: string;
    endpoint: string;
    method: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
    parameters: Array<Parameter>;
    body?: {
        [key: string]: unknown;
    };
};
export type ValidParameters = ZodObject<{
    [key: string]: ZodString | ZodOptional<ZodString>;
}>;
export type Parameters = ValidParameters | z.ZodObject<{}>;
type inferParameters<PARAMETERS extends Parameters> = PARAMETERS extends ValidParameters ? z.infer<PARAMETERS> : z.infer<z.ZodObject<{}>>;
type CreateActionOptions<P extends Parameters = z.ZodObject<{}>> = {
    actionName?: string;
    toolName?: string;
    description?: string;
    inputParams?: P;
    callback: (inputParams: inferParameters<P>, authCredentials: Record<string, string> | undefined, executeRequest: (data: RawExecuteRequestParam) => Promise<ActionExecuteResponse>) => Promise<ActionExecuteResponse>;
};
interface ExecuteMetadata {
    entityId?: string;
    connectionId?: string;
}
export declare class ActionRegistry {
    client: Composio;
    customActions: Map<string, {
        metadata: CreateActionOptions;
        schema: Record<string, unknown>;
    }>;
    constructor(client: Composio);
    createAction<P extends Parameters = z.ZodObject<{}>>(options: CreateActionOptions<P>): Promise<RawActionData>;
    getActions({ actions, }: {
        actions: Array<string>;
    }): Promise<Array<RawActionData>>;
    getAllActions(): Promise<Array<RawActionData>>;
    executeAction(name: string, inputParams: Record<string, unknown>, metadata: ExecuteMetadata): Promise<ActionExecuteResponse>;
}

export type ExecuteActionParams = z.infer<typeof ZExecuteActionParams> & {
    /** @deprecated use actionName field instead */
    action?: string;
    actionName?: string;
};
export declare class ComposioToolSet {
    client: Composio;
    apiKey: string;
    runtime: string | null;
    entityId: string;
    connectedAccountIds: Record<string, string>;
    backendClient: AxiosBackendClient;
    connectedAccounts: ConnectedAccounts;
    apps: Apps;
    actions: Actions;
    triggers: Triggers;
    integrations: Integrations;
    activeTriggers: ActiveTriggers;
    userActionRegistry: ActionRegistry;
    private internalProcessors;
    private userDefinedProcessors;
    /**
     * Creates a new instance of ComposioToolSet
     * @param {Object} config - Configuration object
     * @param {string|null} config.apiKey - API key for authentication
     * @param {string|null} config.baseUrl - Base URL for API requests
     * @param {string|null} config.runtime - Runtime environment
     * @param {string} config.entityId - Entity ID for operations
     * @param {Record<string, string>} config.connectedAccountIds - Map of app names to their connected account IDs
     * @param {boolean} config.allowTracing - Whether to allow tracing for the SDK
     */
    constructor({ apiKey, baseUrl, runtime, entityId, connectedAccountIds, allowTracing, }?: {
        apiKey?: string | null;
        baseUrl?: string | null;
        runtime?: string | null;
        entityId?: string;
        connectedAccountIds?: Record<string, string>;
        allowTracing?: boolean;
    });
    getActionsSchema(filters?: {
        actions?: Optional$1<Sequence<string>>;
    }, _entityId?: Optional$1<string>): Promise<{
        metadata: {
            name: string;
            toolName?: string | undefined;
        };
        name: string;
        appId: string;
        appName: string;
        description: string;
        display_name: string;
        logo: string;
        enabled: boolean;
        parameters: {
            type: string;
            description: string;
            required: string[];
            properties: Record<string, any>;
            title: string;
        };
        appKey: string;
        tags: string[];
        response: Record<string, any>;
    }[]>;
    getToolsSchema(filters: z.infer<typeof ZToolSchemaFilter>, _entityId?: Optional$1<string>, _integrationId?: Optional$1<string>): Promise<RawActionData[]>;
    createAction<P extends Parameters = z.ZodObject<{}>>(options: CreateActionOptions<P>): Promise<{
        metadata: {
            name: string;
            toolName?: string | undefined;
        };
        name: string;
        appId: string;
        appName: string;
        description: string;
        display_name: string;
        logo: string;
        enabled: boolean;
        parameters: {
            type: string;
            description: string;
            required: string[];
            properties: Record<string, any>;
            title: string;
        };
        appKey: string;
        tags: string[];
        response: Record<string, any>;
    }>;
    private isCustomAction;
    getEntity(entityId: string): Promise<Entity>;
    executeAction(functionParams: ExecuteActionParams): Promise<ActionExecuteResponse>;
    private processResponse;
    addSchemaProcessor(processor: TSchemaProcessor): Promise<this>;
    addPreProcessor(processor: TPreProcessor): Promise<this>;
    addPostProcessor(processor: TPostProcessor): Promise<this>;
    removePreProcessor(): Promise<void>;
    removePostProcessor(): Promise<void>;
    removeSchemaProcessor(): Promise<void>;
}

/**
 * CloudflareToolSet provides integration with Cloudflare Workers AI
 * for executing AI tool calls and handling responses
 */
export declare class CloudflareToolSet extends ComposioToolSet {
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    /**
     * Initialize a new CloudflareToolSet instance
     *
     * @param config Configuration options including API key, base URL, entity ID and workspace config
     */
    constructor(config?: {
        apiKey?: Optional$1<string>;
        baseUrl?: Optional$1<string>;
        entityId?: string;
        connectedAccountIds?: Record<string, string>;
        allowTracing?: boolean;
    });
    /**
     * Retrieve available tools based on provided filters
     *
     * @param filters Optional filters for actions, apps, tags and use cases
     * @returns Promise resolving to array of AI text generation tools
     */
    getTools(filters: z.infer<typeof ZToolSchemaFilter>): Promise<Sequence<AiTextGenerationToolInput>>;
    /**
     * Execute a single tool call
     *
     * @param tool The tool to execute with name and arguments
     * @param entityId Optional entity ID to execute the tool for
     * @returns Promise resolving to stringified tool execution result
     */
    executeToolCall(tool: {
        name: string;
        arguments: unknown;
    }, entityId?: Optional$1<string>): Promise<string>;
    /**
     * Handle tool calls from AI text generation output
     *
     * @param result The AI text generation output containing tool calls
     * @param entityId Optional entity ID to execute the tools for
     * @returns Promise resolving to array of tool execution results
     */
    handleToolCall(result: AiTextGenerationOutput, entityId?: Optional$1<string>): Promise<Sequence<string>>;
}

export declare class LangchainToolSet extends ComposioToolSet {
    /**
     * Composio toolset for Langchain framework.
     *
     */
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    constructor(config?: {
        apiKey?: Optional$1<string>;
        baseUrl?: Optional$1<string>;
        entityId?: string;
        runtime?: string;
        connectedAccountIds?: Record<string, string>;
        allowTracing?: boolean;
    });
    private _wrapTool;
    getTools(filters?: z.infer<typeof ZToolSchemaFilter>, entityId?: Optional$1<string>): Promise<Sequence<DynamicStructuredTool>>;
}

export declare class LangGraphToolSet extends LangchainToolSet {
    /**
     * Composio toolset for Langgraph framework.
     *
     */
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    constructor(config?: {
        apiKey?: Optional$1<string>;
        baseUrl?: Optional$1<string>;
        entityId?: string;
        connectedAccountIds?: Record<string, string>;
        allowTracing?: boolean;
    });
}

export declare class OpenAIToolSet extends ComposioToolSet {
    static FRAMEWORK_NAME: string;
    static DEFAULT_ENTITY_ID: string;
    fileName: string;
    /**
     * Composio toolset for OpenAI framework.
     *
     * Example:
     * ```typescript
     *
     * ```
     */
    constructor(config?: {
        apiKey?: Optional$1<string>;
        baseUrl?: Optional$1<string>;
        entityId?: string;
        connectedAccountIds?: Record<string, string>;
        allowTracing?: boolean;
    });
    getTools(filters: z.infer<typeof ZToolSchemaFilter>, entityId?: Optional$1<string>): Promise<Sequence<OpenAI.ChatCompletionTool>>;
    executeToolCall(tool: OpenAI.ChatCompletionMessageToolCall, entityId?: Optional$1<string>): Promise<string>;
    handleToolCall(chatCompletion: OpenAI.ChatCompletion, entityId?: Optional$1<string>): Promise<Sequence<string>>;
    handleAssistantMessage(run: OpenAI.Beta.Threads.Run, entityId?: Optional$1<string>): Promise<Array<OpenAI.Beta.Threads.Runs.RunSubmitToolOutputsParams.ToolOutput>>;
    waitAndHandleAssistantStreamToolCalls(client: OpenAI, runStream: Stream<OpenAI.Beta.Assistants.AssistantStreamEvent>, thread: OpenAI.Beta.Threads.Thread, entityId?: string | null): AsyncGenerator<unknown, void, unknown>;
    waitAndHandleAssistantToolCalls(client: OpenAI, run: OpenAI.Beta.Threads.Run, thread: OpenAI.Beta.Threads.Thread, entityId?: Optional$1<string>): Promise<OpenAI.Beta.Threads.Run>;
}

type Optional<T> = T | null;
export declare class VercelAIToolSet extends ComposioToolSet {
    fileName: string;
    constructor(config?: {
        apiKey?: Optional<string>;
        baseUrl?: Optional<string>;
        entityId?: string;
        connectedAccountIds?: Record<string, string>;
        allowTracing?: boolean;
    });
    private generateVercelTool;
    getTools(filters: {
        actions?: Array<string>;
        apps?: Array<string>;
        tags?: Optional<Array<string>>;
        useCase?: Optional<string>;
        usecaseLimit?: Optional<number>;
        filterByAvailableApps?: Optional<boolean>;
        integrationId?: Optional<string>;
    }, entityId?: Optional<string>): Promise<{
        [key: string]: CoreTool;
    }>;
    executeToolCall(tool: {
        name: string;
        arguments: unknown;
    }, entityId?: Optional<string>): Promise<string>;
}

/**
 * Custom error class for Composio that provides rich error details, tracking, and improved debugging
 */
export declare class ComposioError extends Error {
    readonly timestamp: string;
    readonly errorId: string;
    readonly errCode: string;
    readonly metadata?: Record<string, unknown>;
    readonly description?: string;
    readonly possibleFix?: string;
    readonly _originalError?: unknown;
    constructor(errCode: string, message: string, description?: string, possibleFix?: string, metadata?: Record<string, unknown>, originalError?: unknown);
    get originalError(): unknown;
    /**
     * Returns a complete object representation for logging/serialization
     * Includes all error details and metadata
     */
    toJSON(): Record<string, unknown>;
}

export declare const COMPOSIO_SDK_ERROR_CODES: {
    BACKEND: {
        NOT_FOUND: string;
        RATE_LIMIT: string;
        BAD_REQUEST: string;
        UNAUTHORIZED: string;
        SERVER_ERROR: string;
        SERVER_UNAVAILABLE: string;
        SERVER_UNREACHABLE: string;
        UNKNOWN: string;
    };
    COMMON: {
        API_KEY_UNAVAILABLE: string;
        BASE_URL_NOT_REACHABLE: string;
        UNKNOWN: string;
        SERVER_UNAVAILABLE: string;
        REQUEST_TIMEOUT: string;
        REQUEST_ABORTED: string;
        INVALID_PARAMS_PASSED: string;
    };
    SDK: {
        NO_CONNECTED_ACCOUNT_FOUND: string;
        FAILED_TO_INITIATE_CONNECTION: string;
        INVALID_PARAMETER: string;
    };
};

export declare const APPS: any;
export declare const ACTIONS: any;

export { ACTIONS, APPS, COMPOSIO_SDK_ERROR_CODES, CloudflareToolSet, Composio, ComposioError, ComposioToolSet, ConnectionRequest, LangGraphToolSet, LangchainToolSet, OpenAIToolSet, VercelAIToolSet };
