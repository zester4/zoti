import { IterableReadableStream } from "@langchain/core/utils/stream";
export class IterableReadableWritableStream extends IterableReadableStream {
    get closed() {
        return this._closed;
    }
    constructor(params) {
        let streamControllerPromiseResolver;
        const streamControllerPromise = new Promise((resolve) => {
            streamControllerPromiseResolver = resolve;
        });
        super({
            start: (controller) => {
                streamControllerPromiseResolver(controller);
            },
        });
        Object.defineProperty(this, "modes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "controller", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "passthroughFn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        // .start() will always be called before the stream can be interacted
        // with anyway
        void streamControllerPromise.then((controller) => {
            this.controller = controller;
        });
        this.passthroughFn = params.passthroughFn;
        this.modes = params.modes;
    }
    push(chunk) {
        this.passthroughFn?.(chunk);
        this.controller.enqueue(chunk);
    }
    close() {
        try {
            this.controller.close();
        }
        catch (e) {
            // pass
        }
        finally {
            this._closed = true;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error(e) {
        this.controller.error(e);
    }
}
//# sourceMappingURL=stream.js.map